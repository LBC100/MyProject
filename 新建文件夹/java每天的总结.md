## 什么是标识符?
 1. 在java源程序当中凡是程序员有权利自己命名的单词都是标识符.
 2. 标识符可以标识什么元素?
       

## 数据类型
1. 数据类型的作用是什么?
  - 程序中有很多数据, 没一个数据都是有相关类型的, 不同数据类型的数据占用空间大小不同.
  - 数据类型的作用是指导JVM在运行程序的时候给该数据分配多大的内存空间
        
2. 基本数据类型
    - 基本数据类型包括四大类八小种
      - 第一类: 整数型
        byte, short, int, long
      - 第二类: 浮点型
        float, double
      - 第三类: 布尔型
        boolean
      - 第四类: 字符型
        char
    
3. 字符串"abc" 不属于基本数据类型, 属于"引用数据类型", 字符属于基本数据类型.
    - 字符串使用双引号 "abc"
    - 字符使用单引号 'a'

4. 基本数据类型    占用空间

		byte       	 1
		short         2
		int           4
		long          8
		float         4
		double        8
		boolean       1
		char          2
        
## 字符串 需要字符编码

## static 成员变量 会有默认值
    static int k;  // 默认为0

	局部变量不会有默认值
	    int k = 1000;

## 引用数据类型
  - 类
  - 接口
  - 数组

## java语言当中的整数型字面值有三中表示方式:
1. 十进制(默认的方式)
2. 八进制(以0开始, 如: 010 表示 8)
3. 十六进制(以0x开始, 如: 0x10 表示 16)

## 存在自动类型转换. 
- 小容量可以自动转换成大容量, 称为自动类型转换
- 如

		long x = 456;
		long y = 2147483648; // 报错, 因为默认是int类型, 但是这个数字已经超出int的数值范围了.
		long y = 2147483648L; // 正确
	
- 大容量转换成小容量, 需要进行强制类型转换, 强制类型转换可能会损失精度, 应当谨慎使用.
- 如

	    long x = 100L;
	    int y = x; // 编译报错
		
	    int y = (int)x; // 强制类型转换, 可能会损失精度
		
	    例子: 
	      long k = 2147473648L;
	      int e = (int)k;
	      System.out.println(e); // 损失精度严重, 结果是负数

## 当一个整数字面值没有超出byte, short, char的取值范围, 这个字面值可以直接赋值给byte, shrt, char类型的变量. 这种机制SUN允许了, 目的是为方便程序员编程
	- 大容量转换成小容量是需要添加强制类型转换, byte, short, char的 是特殊情况
	    byte b = 50; // 不报错, java 的特殊对待
	    byte b1 = 128; // 报错

## 关于浮点类型数据类型:
- float 单精度(4个字节)
- double 双进度(8个字节, 精度较高)

- double的精度太低(相对来说), 不适合做财务软件.
    SUN在基础se类库当中为程序员准备了精确度更高的类型, 
    这是一种引用数据类型, 不属于基本数据类型, 它是: java.math.BigDecimal

- 在java语音中, 所有的浮点型字面值(3.0), 
	默认被当做double类型来处理, 要想该字面值当做float类型来处理, 需要在字面值后面添加F/f
	
	    float f = 5.1 // 报错
	
	    解决方案
	      1.
	        float f = (float)5.1; // 强制类型转换
	
	      2.
	        float f = 5.1F; // 没有类型转换

## 注意:double和float在计算机储存的都是近似值

## 转换规则
1. 八种基本数据类型当中除布尔类型之外, 其他7种类型都可以互相转换
2. 容量排序
  byte < short, char < int < long < float < double
  - 注: 任何浮点类型不管占用多少个字节, 都比整数型容量大.
3. 大容量转换成小容量需要加类型转换符. 可能会损失精度, 所有谨慎使用
4. 当整数字面值没有超出byte, short, char的取值范围, 可以直接赋值.
5. byte, short, char混合运算的时候, 各自先转换成int类型再做运算.
6. 多种数据类型混合运算, 先转换容量最大的那种类型再做运算.
	- 如:
	
			double dd = 10 / 3; // 3.0
			dd = 10.0 / 3; // 3.333333333335


## 运算符
1. 算术运算符
	1. ++ 出现在变量后. 规则: 先做赋值运算, 再对变量中保存的值进行自加1.反之亦然
		
	        int a = 100;
	        int b = a ++;
	        // 先赋值再++.  a = 101,   b = 100
		
	2. 关系运算符
		
	3. 逻辑运算符
		    &   逻辑与    (两边的算子都是true, 结果才是true)
		    |   逻辑或    (两边的算子只要有一个true, 结果就是true)
		    !   逻辑非    (取反)
		    ^   逻辑异或  (两边的算子只要不一样, 结果就是true) 
		        (true ^ false)  true
		        (true ^ true)   false
		        (false ^ false) false
		
	   
	4. 什么时候使用短路与?
		- &&  短路与
		- ||  短路或
		- 后面的表达式不需要执行的时候.
		- 实际开发&&用得比较多


## 关于switch语句
1. switch语句也属于选择结构也是分支语句
2. switch语句的语法结构

		switch(int或String类型的字面值或变量) {
			case int或String类型的字面值或变量 :
				java语句
				break;
			case int或String类型的字面值或变量 :
				java语句
				break;
			default:
				java语句
				break;
		}


## 循环
1. for循环
	- 批量执行.
	- break; 被翻译为"中断/折断"
		- 终止循环语句
		- 如: 找数据, 找到后不需要继续执行.
	- 语法结构
	
			for(初始化表达式; 布尔表达式; 更新表达式) {
				循环体
			}				
		
2. while循环
3. do..while循环
	- 先循环一次再判断
	
			do {
				循环体;
			}while(布尔表达式);

## 循环控制语句
1. break; 被翻译为"中断/折断"
	- 终止循环语句
	- 如: 找数据, 找到后不需要继续执行.
2. continut; 继续/go on/下一个
	- 当前本次循环结束.
	-  不执行 continut 下面的代码, 跳过, 执行下一次循环.
		
## 方法
1. 方法定义在类体当中.
		
		public class test1 {
			  public static void main(String[] args) {
			
			    test1.testFn();
			  }
			
			  public static void testFn () {
			    System.out.println(123);
			  }
		}
 
## 方法在执行过程中, 在JVM中的内存四如何分配的?内存是如何变化的?
1. 方法只定义, 不调用, 是不会执行的, 并且在jvm中页不会给该方法分配"运行所属"的内存空间.只有在调用这个方法的时候, 才会动态的给这个方法分配所属的内存空间.
2. 在jvm内存划分有这样三块主要的内存空间(当然除了这三块之外还有其他的内存空间):
	- 方法区内存
	- 堆内存
	- 栈内存
3. 关于栈数据结构
	- 栈: stack, 是一种数据结构
	- 数据结构反应的是数据的存储形态.
	- 数据结构是独立的学科, 不属于任何编程语言的范畴. 只不过在大多数编程语言当中要使用数据结构.
4. 方法代码片段属于.class字节码文件的一部分, 字节码文件在类加载的时候, 将其放到了方法区当中. 所有jvm的三块主要的内存空间中方法区内存最先有数据. 存放了代码片段.
5. 代码片段虽然在方法区内存当中只有一份, 但是可以被重复调用. 每一次调用这个方法的时候, 需要给该方法分配独立的活动场所, 在栈内存中分配. (栈内存中分配方法运行的所属内存空)
	- 方法在调用的瞬间, 会给该方法分配内存空间, 会在栈中发生压栈动作, 方法执行结束之后, 给该方法分配的内存空间全部释放, 此时发生弹栈动作.
6. 局部变量在"方法体"中声明. 局部变量在运行阶段内存在栈中分配.

## 方法重载 overload
1. https://www.bilibili.com/video/BV1Rx411876f?p=98
2. 在程序当中功能相似的方法, 分别起了多个不同的名字, 这对于程序员来说, 调用方法的时候不方便, 程序员需要记忆更多的方法, 才能完成调用.
3. 参数的类型不同, 调用的方法不同. 此时区分方法不再依靠方法名了, 依靠的是参数的数据类型. https://www.bilibili.com/video/BV1Rx411876f?p=99
4. 什么条件满足之后构成了方法重载
	- 在同一个类当中
	- 方法名相同
	- 参数列表不同
		- 数量不同
		- 类型不同
		- 顺序不同
5. 方法重载和什么有关系?
	- 方法重载和方法名 + 参数类别有关系
	- 方法重载和返回值类型无关
	- 方法重载和修饰符列表无关
	

## 对象
1. new 在堆内存存储
2. java语言当中, 程序员只能通过"引用"去访问堆内存当中对象内部的实例变量.
3. 实例变量是一个对象一份, 100个对象有100份.
4. 对象创建没赋值, 会有默认值
5. https://www.bilibili.com/video/BV1Rx411876f?p=115 对象的创建
6. 实例变量必须先创建对象, 通过引用.的方式访问, 不能直接使用类名.的方式访问
	- System.out.println(Product.productNo); // 编译报错
7. **重点: 没有static关键字的方法被称为"实例方法"**
8. **重点: 没有static关键字的变量被称为"实例变量"**
9. **实例变量在堆内存的对象内部存储**, 所以访问改数据的时候, 必须先创建对象, 通过引用方式访问.

	
## 对象封装
1. 封装的步骤
	- 所有属性私有化, 使用private关键字进行修饰, 修饰后所有数据只能在本类访问.
	- 对外提供简单的操作入口.
		- 对外提供两个公开的方法, 分别是set方法和get方法.
	- get, set方法命名规范.
		
			public void setAge(int a) {
				age = a;
			}
			public int getAge() {
				return age;
			}

## static关键字
1. **有static关键字修饰的方法怎么调用: 类名.方法名(实参);**
	- 有stati方法是绑在类上的.
2. **没有static关键字修饰的方法怎么调用: 引用.方法名(实参);**
	- 没有static方法是绑在引用上的.


## java类中的构造方法
1. 构造方法的方法名必须和类名一致.
2. 构造方法的作用?
	- 构造方法存在的意义是, 通过构造方法的调用, 可以创建对象.
	- **创建对象的同时, 初始化实例变量的内存空间.(给实例变量赋值)**
3. 构造方法怎么调用?
	- 普通方法是这样调用的: 方法修饰符中有static的时候: 类名.方法名(实参列表); 方法没有static的时候: 引用.方法名(实参列表);
	- new 构造方法(实参列表);  如: new User();
	- 构造方法调用执行之后, 有返回值吗?
		- 每一个构造方法实际上执行结束之后都有返回值, 并且返回值类型是构造方法所在类的类型.
	- 当一个类中没有构造方法, 系统会默认有一个构造方法.
	- **当一个类显示的将构造方法定义出来了, 那么系统则不再默认为这个类提供缺省构造器. 建议开发找那个手动的为当前类提供无参构造方法.因为无参数构造方法太常用了.**
	- 构造方法支持重载机制.

## 对象和引用的概念?
1. **对象**: 目前在使用new运算符**在堆内存中开辟的内存空间**称为对象.
2. **引用**: 是一个变量, 不一定是局部变量, 还可能是成员变量. 引用保存了内存地址, 指向了堆内存当中的对象.
3. 所有访问实例相关的数据, 都需要通过"引用."的方式访问, 因为只有通过引用才能找到对象.
4. 只有一个空的引用, 访问对象的实例相关的数据会出现**空指针异常**.

## 关于java语言当中的this关键字:
1. this是一个关键字, 翻译为: 这个
2. this是一个引用, this是一个变量, **this变量中保存了内存地址指向了自身**, this存储在JVM堆内存java对象内部.
3. 创建100个java对象, 每一个对象都有this, 也就说有100个不同的this.

## 栈
1. https://www.bilibili.com/video/BV1Rx411876f?p=92
2. 栈数据结构存储数据的特点是:
	- 先进后出
	- 后进先出

	
## 队列
1. 先进先出